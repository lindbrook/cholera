---
title: "Voronoi Diagrams with Longitude and Latitude Data"
output: github_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cholera)
library(geosphere)
library(terra)
```

## introduction

This is a work-in-progress note about how I compute Voronoi diagrams with geographic data (data with longitude and latitude). The elephant-in-the-room is why not use [spatial](https://rspatial.org/) or [GIS](https://qgis.org/) tools and approaches? Right now, my preference is to try to extend the functionality of the existing code to include geographic data. In the long run, this may not turn out to be the best strategy. If any of the below seems wrong (be it obvious or subtle, technical or conceptual), feel free to share your insights.

## georeferencing Dodson and Tobler (1992)

Dodson and Tobler (1992) digitized John Snow's map by applying an arbitrary "nominal" set of Cartesian coordinates to the data. Using a modified version of those data, I estimated the longitude and latitude of the nominal coordinates by using the "Georeferencer" tool and the [OpenStreetMap](https://www.openstreetmap.org) XYZ tiles in [QGIS](https://qgis.org/).

## what are Voronoi diagrams?

The best way to understand what a Voronoi diagram is and how it works is through an example.

Consider the coffee shops in your town. For the sake of illustration, we'll assume that "all else being equal" (price, quality, banter, etc., are all the same), the only thing that affects your choice will be a shop's proximity. Now, if we were to repeat this computation for everyone in town, we'll see that distinct neighborhoods will emerge. In the diagram below, 13 coffee shops carve up the town's clientele into 13 neighborhoods:

```{r voronoi}
snowMap()
addVoronoi()
```

In my case, the data above are not coffee shops but water pumps in 1854 Soho (Westminster, UK). The cells identify which people should use which pump (a residence on a boundary (cell edge) is equally close to the pump's in adjacent neighborhoods).

## the "brute force" computation of Voronoi diagrams

The neat thing about Voronoi algorithms is that they don't use the "brute force" method described above. They don't compute the proximity for each individual. Instead, they generate the same result using only the locations of water pumps (or coffee houses, etc.).

As "proof", compare the diagram above, which only leverages pump location, with the one below, which uses the "brute force" approach.

```{r euclidean_paths}
plot(neighborhoodEuclidean(case.set = "expected"), type = "star")
```

To create the "brute force" diagram, I place 20,000 regularly spaced points across the face of the map. I then computed the (Euclidean) distance from each of these points to each of the 13 water pumps. A line (color-coded by pump) is then plotted between a point and its closest water pump. What emerges is a kind of photographic negative or inverse of the first Voronoi diagram, which only used pump location. This not only demonstrates the equivalence of the two approaches, it also gives us a separate, independent way to validate a Voronoi diagram. This is what will help us assess whether my effort to compute Voronoi diagrams with geographic data is reasonable if not "right".

## the problem

The problem is that we can't simply apply deldir::deldir(), a 2D algorithm, to data with geographic coordinates. You'll get the "wrong" answer.

Compare the following.

```{r voronoi_nominal}
snowMap(latlong = FALSE)
pmp <- cholera::pumps
vars <- c("x", "y")
cells <- cholera::voronoiPolygons(pmp[, vars], rw.data = cholera::roads[, vars],
  latlong = FALSE )
invisible(lapply(cells, polygon))
title(main = "Nominal Coordinates")
```

```{r voronoi_naive}
snowMap(latlong = TRUE)
pmp <- cholera::pumps
vars <- c("lon", "lat")
cells <- cholera::voronoiPolygons(pmp[, vars], rw.data = cholera::roads[, vars],
  latlong = TRUE )
invisible(lapply(cells, polygon))
title(main = "Geographic Coordinates")
```

Code-wise, the only difference between the two is that the former uses the nominal coordinates while the latter uses geographic ones. Visually, the difference lies with the Voronoi diagrams. You can see this, if we remove them:

```{r latlong, fig.align = "default", fig.width = 5.5, fig.height = 5.5, fig.show = "hold", out.width = "50%"}
snowMap()
snowMap(latlong = TRUE)
```

Other than the aspect ratio used to create the graphs (the nominal plot uses asp = 1, the geographic plot uses asp = 1.65), the shape of road network and the relative locations of the water pumps essentially look the same. And because the location of pumps is the only data used by the Voronoi algorithm, you might expect to get similar rather than differen Voronoi diagrams.

These facts raise two questions. First, why then are the two diagrams different? Second, does that difference matter? The answer to the first question is that is essentially a numerical issue. The answer to the second question is that the naive application of the algorithm to geographic data leads to what we might call classification errors.

## classification error

The diagrams are not just different. One is "wrong". To show this, I leverage the fact that there is a separate, independent way from the algorithm to compute a Voronoi diagram: the "brute force" method described above. By doing so, it's pretty straighforward to show that the diagram computed using geographic coordinate mis-classifies the data.

The tasks. First, directly apply the Voronoi diagram algorithm to geographic data. Second, separately compute the geodesic distance from each observed fatality to its nearest pump.

#### some variables and parameters

```{r variables}
vars <- c("lon", "lat")
asp <- 1.65
cases <- cholera::fatalities.address
rng <- mapRange(latlong = TRUE)
snow.colors <- snowColors(vestry = FALSE)
```

To compute and visualize the nearest pumps, I don't directly use the geographic coordinates. Instead, I compute the actualy physical distance between the coordinates along the Earth's surface based on a 3D model (WGS84 ellipsoid model). This is known as the geodesic or great circle distance. I compute this using via geosphere::distGeo().

For each residence in the dataset that witnessed at least one fatality, I compute which pump is nearest:

#### computation of geodesic distance to nearest pump

```{r geodesic_distance}
nearest.pump <- do.call(rbind, lapply(cases$anchor, function(x) {
  p1 <- cases[cases$anchor == x, vars]
  d <- vapply(pumps$id, function(p) {
    p2 <- pumps[pumps$id == p, vars]
    geosphere::distGeo(p1, p2)
  }, numeric(1L))
  nearest <- which.min(d)
  data.frame(case = x, pump = pumps$id[pumps$id == nearest],
    meters = d[nearest])
}))
```

In the code below, I plot the Voronoi cells. Then, using `nearst.pump`, I draw a line segment from the fatality's location to the nearest pump  (color-code the segment by which pump is closest). You can see the discrepancy between the cells and the lines. This show the mis-classification.

```{r euclidean_paths_latlong_naive}
# plot roads and pumps
plot(cases[, vars], xlim = rng$x, ylim = rng$y, pch = NA, asp = asp)
addRoads(vars)
points(pumps[, vars], pch = 17, col = snow.colors, cex = 1)

# compute Voronoi cells by directly applying the algorithm to geographic data
cells <- cholera::voronoiPolygons(cholera::pumps[, vars],
  rw.data = cholera::roads[, vars], latlong = TRUE)

# plot Voronoi cells
invisible(lapply(cells, polygon))

# plot color-coded line segment from fatality to pump
invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  alter <- pumps[pumps$id == p, vars]
  segments(ego$lon, ego$lat, alter$lon, alter$lat,
    col = snow.colors[paste0("p", p)])
}))

# plot color-coded fatalities
invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  points(ego, pch = 16, col = snow.colors[paste0("p", p)], cex = 2/3)
}))
```

## numerical expectations

The reason why the direct application of the algorithm to geographic data leads to the mis-classification is essentially numerical.

It stems from the fact that even though the Earth is round, the \emph{algorithm} sees the Earth as flat. The algorithm expects a 2D Cartesian world where the only difference between the two axes is that they are perpendicular or orthogonal to one another. To be specific, it expects that the distance covered by a one unit move North or South (a unit change in latitude) will equal the distance covered by a one unit move East or West (a unit change in longitude). Due to the Earth's geometry, this is not the case. As you move North or South, away the equator and toward the poles, the distance covered as you move one unit East or West (longitude) will actually decrease: even though they cover the same number of degrees of longitude, the distance along the Equator is greater than that along either the Tropic of Cancer or Capricorn.

## a solution

In the graph below, I plot my solution. Here you can see the concordance between the line segments and the Voronoi diagram.

```{r euclidean_paths_latlong}
plot(cases[, vars], xlim = rng$x, ylim = rng$y, pch = NA, asp = asp)
addRoads(vars)
points(pumps[, vars], pch = 17, col = snow.colors, cex = 1)

cells <- cholera::latlongVoronoiC()
invisible(lapply(cells, function(dat) polygon(dat[, vars])))

invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  alter <- pumps[pumps$id == p, vars]
  segments(ego$lon, ego$lat, alter$lon, alter$lat, lwd = 0.5,
    col = snow.colors[paste0("p", p)])
}))

invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  points(ego, pch = 16, col = snow.colors[paste0("p", p)], cex = 0.5)
}))

cells <- cholera::latlongVoronoiC()
invisible(lapply(cells, function(dat) polygon(dat[, vars])))
```

# latlongVoronoiC()

## four corners

Origin is bottom left; graph in quadrant I

```{r four_corners}
origin <- data.frame(lon = min(cholera::roads$lon),
                     lat = min(cholera::roads$lat))
topleft <- data.frame(lon = min(cholera::roads$lon),
                      lat = max(cholera::roads$lat))
bottomright <- data.frame(lon = max(cholera::roads$lon),
                          lat = min(cholera::roads$lat))
topright <- data.frame(lon = max(cholera::roads$lon),
                       lat = max(cholera::roads$lat))
```

## decompose geodesic distance into horizontal and vertical

Compute geodesic distance from origin to points and decompose

```{r decomposed_coordinates}
pump.data <- cholera::pumps

pump.meters <- do.call(rbind, lapply(pump.data$id, function(p) {
  pmp <- pump.data[pump.data$id == p, c("lon", "lat")]
  x.proj <- c(pmp$lon, origin$lat)
  y.proj <- c(origin$lon, pmp$lat)
  m.lon <- geosphere::distGeo(y.proj, pmp)
  m.lat <- geosphere::distGeo(x.proj, pmp)
  data.frame(pump = p, x = m.lon, y = m.lat)
}))
```

## bounding box of Voronoi diagram

```{r, bounding_box}
height <- geosphere::distGeo(origin, topleft)
width <- geosphere::distGeo(origin, bottomright)
bounding.box <- c(0, width, 0, height)
```

## cell coordinates

Apply deldir::deldir() and extract coordinates of cells, with an eye to using polygon().

```{r, cell_coords}
cells <- voronoiPolygons(pump.meters[, c("x", "y")], rw = bounding.box)
```

## reshape and reformat into data frame

```{r, format data}
cells.df <- do.call(rbind, cells)
cells.lat <- sort(unique(cells.df$y), decreasing = TRUE) # unique latitudes
tmp <- row.names(cells.df)
ids <- do.call(rbind, strsplit(tmp, "[.]"))
cells.df$cell <- as.numeric(ids[, 2])
cells.df$vertex <- as.numeric(ids[, 3])
row.names(cells.df) <- NULL
```

## meterLatitude()

```{r, meterLatitude}
meterLatitude <- function(cells.df, origin, topleft, delta = 0.000025) {
  lat <- seq(origin$lat, topleft$lat, delta)

  meters.north <- vapply(lat, function(y) {
    geosphere::distGeo(origin, cbind(origin$lon, y))
  }, numeric(1L))

  loess.lat <- stats::loess(lat ~ meters.north,
    control = stats::loess.control(surface = "direct"))

  y.unique <- sort(unique(cells.df$y))

  est.lat <- vapply(y.unique, function(m) {
    stats::predict(loess.lat, newdata = data.frame(meters.north = m))
  }, numeric(1L))

  data.frame(m = y.unique, lat = est.lat)
}
```

## meterLatLong()

```{r meterLatLong}
meterLatLong <- function(cells.df, origin, topleft, bottomright,
  delta = 0.000025) {

  est.lat <- meterLatitude(cells.df, origin, topleft)

  # uniformly spaced points along x-axis (longitude)
  lon <- seq(origin$lon, bottomright$lon, delta)

  # a set of horizontal distances (East-West) for each estimated latitude
  meters.east <- lapply(est.lat$lat, function(y) {
    y.axis.origin <- cbind(origin$lon, y)
    vapply(lon, function(x) {
      geosphere::distGeo(y.axis.origin, cbind(x, y))
    }, numeric(1L))
  })

  loess.lon <- lapply(meters.east, function(m) {
    dat <- data.frame(lon = lon, m)
    stats::loess(lon ~ m, data = dat,
      control = stats::loess.control(surface = "direct"))
  })

  y.unique <- sort(unique(cells.df$y))

  # estimate longitudes, append estimated latitudes
  est.lonlat <- do.call(rbind, lapply(seq_along(y.unique), function(i) {
    dat <- cells.df[cells.df$y == y.unique[i], ]
    loess.fit <- loess.lon[[i]]
    dat$lon <- vapply(dat$x, function(x) {
      stats::predict(loess.fit, newdata = data.frame(m = x))
    }, numeric(1L))
    dat$lat <- est.lat[est.lat$m == y.unique[i], "lat"]
    dat
  }))

  est.lonlat[order(est.lonlat$cell, est.lonlat$vertex), ]
}
```

## translate back to longitude and latitude

```{r, translation}
est.lonlat <- meterLatLong(cells.df, origin, topleft, bottomright)
longlat <- split(est.lonlat, est.lonlat$cell)
```

```{r sample_data}
longlat[[1]]
```

## 'terra' implementation

```{r, terra_data}
dat <- cholera::pumps[, c("lon", "lat")]

sv.data <- terra::vect(dat, crs = "+proj=longlat")
proj <- "+proj=lcc +lat_1=51.510 +lat_2=51.516 +lat_0=51.513 +lon_0=-0.1367 +units=m"
sv.proj <- project(sv.data, proj)

v1 <- terra::voronoi(sv.proj)
v2 <- terra::voronoi(sv.data)
out1 <- terra::project(v1, "+proj=longlat")
out2 <- terra::project(v2, "+proj=longlat")
```

```{r, terra1, fig.heigh = 5, fig.width = 5, fig.align = "center"}
plot(out1, xlim = range(cholera::roads$lon), ylim = range(cholera::roads$lat))
addRoads(c("lon", "lat"))
points(cholera::pumps[, c("lon", "lat")])
text(cholera::pumps[, c("lon", "lat")], labels = paste0("p", 1:13), pos = 1)
```

```{r, terra2, fig.heigh = 5, fig.width = 5, fig.align = "center"}
plot(out2, xlim = range(cholera::roads$lon), ylim = range(cholera::roads$lat))
addRoads(c("lon", "lat"))
points(cholera::pumps[, c("lon", "lat")])
text(cholera::pumps[, c("lon", "lat")], labels = paste0("p", 1:13), pos = 1)
```
