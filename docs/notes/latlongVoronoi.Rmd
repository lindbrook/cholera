---
title: "Voronoi Diagrams with Longitude and Latitude Data"
output: github_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(cholera)
library(geosphere)
library(terra)
```

## introduction

This is a work-in-progress note about how I'm approaching the computation and visualization of Voronoi diagrams with geographic data (with longitude and latitude).

The elephant-in-the-room is why not use [spatial](https://rspatial.org/) or [GIS](https://qgis.org/) tools and approaches? Here're two answers. First, right now I'm simply trying to extend the existing functionality of 'cholera' to include geographic data. Second, I'm not sure whether I can or should port that functionality to those tools and approaches.

## georeferencing Dodson and Tobler (1992)

Dodson and Tobler (1992) digitized John Snow's map by applying an arbitrary, "nominal" Cartesian coordinates to the map (e.g., roads, pumps, fatalities). Using a modified version of those data, I estimated the longitude and latitude of those nominal coordinates by using the "Georeferencer" tool and the [OpenStreetMap](https://www.openstreetmap.org) XYZ tiles in [QGIS](https://qgis.org/).

## what are Voronoi diagrams?

The best way to understand what a Voronoi diagram is and how it works is through an example. Consider the coffee shops in your town. For the sake of illustration, we'll assume that "all else being equal" (price, quality, banter, etc. are the same) and that the only thing that affects your choice will be a shop's proximity to your front door. If everyone in town were to do this computation (i.e., compute the distance to each shop and pick the nearest), distinct neighborhoods will emerge. These neighborhoods make up the cells of a Voronoi diagram.

In my case, I'm interested in how the location of water pumps in 1854 Soho (Westminster, UK) create neighborhoods that identify which people should use which pump. The plot below is a Voronoi diagram that identifies the neighborhoods of the 13 pumps.

```{r voronoi}
snowMap()
addVoronoi()
```

The boundaries or edges of the polygons that form the cutpoints between adjacent neighborhoods.

## "brute force" computation of Voronoi diagrams

The neat thing about the standard Voronoi algorithm is that it only uses the location of the 13 pumps to do the computation. It doesn't do the "brute force" computation described above.

That said, because the "brute force" will give you the same answer, it give us a separate, independent way to validate a Voronoi diagram. This will help us assess whether my effort to compute Voronoi diagrams with geographic data is reasonable if not "right".

As "proof" of the "brute force", consider this diagram.

```{r euclidean_paths}
plot(neighborhoodEuclidean(case.set = "expected"), type = "star")
```

It's created using data simulation. I placed 20,000 regularly spaced points across the face of the map. I then computed the Euclidean distance from each point or "address" to the 13 water pumps. Finally, lines (color-coded by pump) are drawn from an address to that address's nearest pump. What emerges is a kind of photographic negative of the Voronoi diagram plotted above.

## the problem

The problem is that we can't simply apply deldir::deldir(), a 2D algorithm, to data with geographic coordinates. You'll get the "wrong" answer.

Compare the following.

```{r voronoi_nominal}
snowMap(latlong = FALSE)
pmp <- cholera::pumps
vars <- c("x", "y")
cells <- cholera::voronoiPolygons(pmp[, vars], rw.data = cholera::roads[, vars],
  latlong = FALSE )
invisible(lapply(cells, polygon))
title(main = "Nominal Coordinates")
```

```{r voronoi_naive}
snowMap(latlong = TRUE)
pmp <- cholera::pumps
vars <- c("lon", "lat")
cells <- cholera::voronoiPolygons(pmp[, vars], rw.data = cholera::roads[, vars],
  latlong = TRUE )
invisible(lapply(cells, polygon))
title(main = "Geographic Coordinates")
```

Code-wise, the only difference between the two is that the former uses the nominal coordinates while the latter uses geographic coordinates. Visually, the difference lies with the Voronoi diagrams.

I'm going to argue that we should expect to get similar Voronoi diagrams regardless of the coordinates used. Put aside the diagrams for a moment:

```{r latlong, fig.align = "default", fig.width = 5.5, fig.height = 5.5, fig.show = "hold", out.width = "50%"}
snowMap()
snowMap(latlong = TRUE)
```

Other than the aspect ratio used to create the graphs (the nominal plot uses asp = 1, the geographic plot uses asp = 1.65), when we look at the shape of road network and the locations of the water pumps the underlying graphs essentially look the same. The relative location of the pumps is key since they are only the data used by the Voronoi diagram algorithm. Because they are similar, we should expect to get similar Voronoi diagrams.


### graph variables

```{r variables}
vars <- c("lon", "lat")
asp <- 1.65
cases <- cholera::fatalities.address
rng <- mapRange(latlong = TRUE)
snow.colors <- snowColors(vestry = FALSE)
```

### geodesic or great circle distances

```{r geodesic_distance}
nearest.pump <- do.call(rbind, lapply(cases$anchor, function(x) {
  p1 <- cases[cases$anchor == x, vars]
  d <- vapply(pumps$id, function(p) {
    p2 <- pumps[pumps$id == p, vars]
    geosphere::distGeo(p1, p2)
  }, numeric(1L))
  nearest <- which.min(d)
  data.frame(case = x, pump = pumps$id[pumps$id == nearest],
    meters = d[nearest])
}))
```

## classification error

```{r euclidean_paths_latlong_naive}
plot(cases[, vars], xlim = rng$x, ylim = rng$y, pch = NA, asp = asp)
addRoads(vars)

points(pumps[, vars], pch = 17, col = snow.colors, cex = 1)

invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  alter <- pumps[pumps$id == p, vars]
  segments(ego$lon, ego$lat, alter$lon, alter$lat,
    col = snow.colors[paste0("p", p)])
}))

invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  points(ego, pch = 16, col = snow.colors[paste0("p", p)], cex = 2/3)
}))

cells <- cholera::voronoiPolygons(cholera::pumps[, vars],
  rw.data = cholera::roads[, vars], latlong = TRUE)

invisible(lapply(cells, polygon))
```

```{r euclidean_paths_latlong}
plot(cases[, vars], xlim = rng$x, ylim = rng$y, pch = NA, asp = asp)
addRoads(vars)
points(pumps[, vars], pch = 17, col = snow.colors, cex = 1)

invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  alter <- pumps[pumps$id == p, vars]
  segments(ego$lon, ego$lat, alter$lon, alter$lat, lwd = 0.5,
    col = snow.colors[paste0("p", p)])
}))

invisible(lapply(nearest.pump$case, function(x) {
  ego <- cases[cases$anchor == x, vars]
  p <- nearest.pump[nearest.pump$case == x, "pump"]
  points(ego, pch = 16, col = snow.colors[paste0("p", p)], cex = 0.5)
}))

cells <- cholera::latlongVoronoiC()
invisible(lapply(cells, function(dat) polygon(dat[, vars])))
```

# latlongVoronoiC()

## four corners

Origin is bottom left; graph in quadrant I

```{r four_corners}
origin <- data.frame(lon = min(cholera::roads$lon),
                     lat = min(cholera::roads$lat))
topleft <- data.frame(lon = min(cholera::roads$lon),
                      lat = max(cholera::roads$lat))
bottomright <- data.frame(lon = max(cholera::roads$lon),
                          lat = min(cholera::roads$lat))
topright <- data.frame(lon = max(cholera::roads$lon),
                       lat = max(cholera::roads$lat))
```

## decompose geodesic distance into horizontal and vertical

Compute geodesic distance from origin to points and decompose

```{r decomposed_coordinates}
pump.data <- cholera::pumps

pump.meters <- do.call(rbind, lapply(pump.data$id, function(p) {
  pmp <- pump.data[pump.data$id == p, c("lon", "lat")]
  x.proj <- c(pmp$lon, origin$lat)
  y.proj <- c(origin$lon, pmp$lat)
  m.lon <- geosphere::distGeo(y.proj, pmp)
  m.lat <- geosphere::distGeo(x.proj, pmp)
  data.frame(pump = p, x = m.lon, y = m.lat)
}))
```

## bounding box of Voronoi diagram

```{r, bounding_box}
height <- geosphere::distGeo(origin, topleft)
width <- geosphere::distGeo(origin, bottomright)
bounding.box <- c(0, width, 0, height)
```

## cell coordinates

Apply deldir::deldir() and extract coordinates of cells, with an eye to using polygon().

```{r, cell_coords}
cells <- voronoiPolygons(pump.meters[, c("x", "y")], rw = bounding.box)
```

## reshape and reformat into data frame

```{r, format data}
cells.df <- do.call(rbind, cells)
cells.lat <- sort(unique(cells.df$y), decreasing = TRUE) # unique latitudes
tmp <- row.names(cells.df)
ids <- do.call(rbind, strsplit(tmp, "[.]"))
cells.df$cell <- as.numeric(ids[, 2])
cells.df$vertex <- as.numeric(ids[, 3])
row.names(cells.df) <- NULL
```

## meterLatitude()

```{r, meterLatitude}
meterLatitude <- function(cells.df, origin, topleft, delta = 0.000025) {
  lat <- seq(origin$lat, topleft$lat, delta)

  meters.north <- vapply(lat, function(y) {
    geosphere::distGeo(origin, cbind(origin$lon, y))
  }, numeric(1L))

  loess.lat <- stats::loess(lat ~ meters.north,
    control = stats::loess.control(surface = "direct"))

  y.unique <- sort(unique(cells.df$y))

  est.lat <- vapply(y.unique, function(m) {
    stats::predict(loess.lat, newdata = data.frame(meters.north = m))
  }, numeric(1L))

  data.frame(m = y.unique, lat = est.lat)
}
```

## meterLatLong()

```{r meterLatLong}
meterLatLong <- function(cells.df, origin, topleft, bottomright,
  delta = 0.000025) {

  est.lat <- meterLatitude(cells.df, origin, topleft)

  # uniformly spaced points along x-axis (longitude)
  lon <- seq(origin$lon, bottomright$lon, delta)

  # a set of horizontal distances (East-West) for each estimated latitude
  meters.east <- lapply(est.lat$lat, function(y) {
    y.axis.origin <- cbind(origin$lon, y)
    vapply(lon, function(x) {
      geosphere::distGeo(y.axis.origin, cbind(x, y))
    }, numeric(1L))
  })

  loess.lon <- lapply(meters.east, function(m) {
    dat <- data.frame(lon = lon, m)
    stats::loess(lon ~ m, data = dat,
      control = stats::loess.control(surface = "direct"))
  })

  y.unique <- sort(unique(cells.df$y))

  # estimate longitudes, append estimated latitudes
  est.lonlat <- do.call(rbind, lapply(seq_along(y.unique), function(i) {
    dat <- cells.df[cells.df$y == y.unique[i], ]
    loess.fit <- loess.lon[[i]]
    dat$lon <- vapply(dat$x, function(x) {
      stats::predict(loess.fit, newdata = data.frame(m = x))
    }, numeric(1L))
    dat$lat <- est.lat[est.lat$m == y.unique[i], "lat"]
    dat
  }))

  est.lonlat[order(est.lonlat$cell, est.lonlat$vertex), ]
}
```

## translate back to longitude and latitude

```{r, translation}
est.lonlat <- meterLatLong(cells.df, origin, topleft, bottomright)
longlat <- split(est.lonlat, est.lonlat$cell)
```

```{r sample_data}
longlat[[1]]
```

## 'terra' implementation

```{r, terra_data}
dat <- cholera::pumps[, c("lon", "lat")]

sv.data <- terra::vect(dat, crs = "+proj=longlat")
proj <- "+proj=lcc +lat_1=51.510 +lat_2=51.516 +lat_0=51.513 +lon_0=-0.1367 +units=m"
sv.proj <- project(sv.data, proj)

v1 <- terra::voronoi(sv.proj)
v2 <- terra::voronoi(sv.data)
out1 <- terra::project(v1, "+proj=longlat")
out2 <- terra::project(v2, "+proj=longlat")
```

```{r, terra1, fig.heigh = 5, fig.width = 5, fig.align = "center"}
plot(out1, xlim = range(cholera::roads$lon), ylim = range(cholera::roads$lat))
addRoads(c("lon", "lat"))
points(cholera::pumps[, c("lon", "lat")])
text(cholera::pumps[, c("lon", "lat")], labels = paste0("p", 1:13), pos = 1)
```

```{r, terra2, fig.heigh = 5, fig.width = 5, fig.align = "center"}
plot(out2, xlim = range(cholera::roads$lon), ylim = range(cholera::roads$lat))
addRoads(c("lon", "lat"))
points(cholera::pumps[, c("lon", "lat")])
text(cholera::pumps[, c("lon", "lat")], labels = paste0("p", 1:13), pos = 1)
```
